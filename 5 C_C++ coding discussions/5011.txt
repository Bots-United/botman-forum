--------------------------------------------------
Subject: Variable overflow
--------------------------------------------------
12/16/03 at 01:50:45  Posted by: NB (jonn@delfi.lt)
--------------------------------------------------
How to recoginze that the variable after operation will be overflow?
Example:
int a=99999;
int b=99999;
int c;
c=a*b;

--------------------------------------------------
12/16/03 at 05:51:19  Reply by: botman (botman@planethalflife.com)
--------------------------------------------------
There is no simple way to detect overflow in all cases.

If you are familiar with Intel assembly language, you can check the Overflow bit in the status register after a mathematical operation, but this won't always be set properly depending on what code is generated by the compiler.

Try searching on www.google.com for "Intel checking overflow bit" or something similar.

botman

--------------------------------------------------
12/16/03 at 06:43:05  Reply by: PM (pm@racc-ai.com)
--------------------------------------------------
There is one thing you can do, in some simple cases.

If the variable you want to check is 16 bits wide, all you need to do is to compare the results of the operation with the results of the same operation when the operands are 32-bit wide.

unsigned short my_var; // 16-bit wide
bool has_overflown = (unsigned long) ((unsigned short) (my_var * 9999)) != (unsigned long) my_var * (unsigned long) 9999;

else check if the sign has changed. You'll catch only 50% of the overflow cases, though.

bool has_overflown = (my_var > 0 ? ((my_var * 9999) < my_var) : ((my_var * 9999) > my_var));



[modified on 12/16/03 at 06:43:05]
--------------------------------------------------
12/17/03 at 22:45:30  Reply by: botmeister (meister@telus.net)
--------------------------------------------------
There's no simple solution, which is very unfortunate, because C/C++ provides no support for overflow checking.

Using the overflow bit is processor dependent and may be unreliable as botman points out. Using 32 bit (or larger) data types to store results from operations on data types with 16 bits will catch all the overflows. For operations that are performed on 32 bit data types you can use data type "long double" to store the result.

In your example, you could also do something like this without storing results in a larger data type:

int a=99999;
int b=99999;
int c=a*b; 
int d=c/b;

if (d != a){ /*overflow*/ }

however you also need a div by zero check





